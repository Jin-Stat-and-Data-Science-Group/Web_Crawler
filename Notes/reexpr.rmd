# Python re模块正则表达式基础知识

## 正则表达式语法

正则表达式（或RE）指定一组与之匹配的字符串；该模块中的函数可检查特定的字符串
是否与给定的正则表达式匹配。

可以将正则表达式连接起来以形成新的正则表达式。如果A和B都是正则表达式，则AB也是
正则表达式。通常，如果字符串p匹配A，而另一个字符串q匹配B，则字符串pq将匹配AB。除
非A或B包含低优先级运算。

正则表达式可以包含特殊字符和普通字符。大多数普通字符（如`'A'`，`'a'`或`'0'`）是最简单
的正则表达式；他们只是匹配自己。

某些字符（例如`'|'`或`'('`）是特殊的。特殊字符要么代表普通字符类，要么影响解释它们周围的正则表达式的方式。

重复限定符（`*，+，?，{m,n}`，等等）不能直接嵌套。这样可以避免与非贪婪修饰符后缀`'?'`
以及其他实现中的其他修饰符产生歧义。为了将第二次重复应用于内部重复，可以使用括
号。例如，表达式`(?:a{6})*`匹配六个`'a'`字符的任何倍数。

**特殊字符：**

|符号|含义|
| - | - |
|`.`|在默认模式下，它匹配除换行符以外的任何字符。如果指定DOTALL，则它与包括换行符的任何字符匹配。|
|`^`|匹配字符串的开头，在MULTILINE模式下，也匹配每个换行符之后的字符串。|
|`$`|匹配字符串的末尾或在字符串末尾的换行符之前，并且在MULTILINE模式下还匹配换行符的前面。|
|`+`|使结果RE匹配先前RE的1个或多个重复。`ab+`将匹配`'a'`，后跟任意非零的`'b'`；它不会仅匹配`'a'`。|
|`?`|使结果RE匹配先前RE的0或1个重复。`ab?`将匹配`'a'`或`'ab'`。|
|`*?,+?,??`|`'*','+','?'`这三个限定符都是贪婪匹配，它们都尽可能地匹配最多的文本。如果`RE<.*>`匹配`'<a>b<c>'`，它将匹配整个字符串，而不仅仅是`'<a>'`。添加`'?'`限定符使其以非贪婪或最小方式执行匹配之后，匹配的字符尽可能少。使用`RE<.*?>`则只匹配`'<a>'`。|
|`{m}`|指定准确地匹配前一个RE的m个副本。较少的匹配则导致整个RE不匹配。例如，`a{6}`将只匹配6个`'a'`字符，而不是五个。|
|`{m,n}`|使生成的RE匹配前一个RE的m到n个重复，尝试匹配尽可能少的重复。|
|`\`|或者表示转义特殊字符，或表示一个特殊的序列。|
|`[ ]`|表示一个字符串的集合，在这个集合中：1. 字符可以单独列出，例如`[amk]`将匹配`'a'`、`'m'`或`'k'`。 2. 可以通过给出两个字符并用`'-'`分隔它们来表示字符范围，例如`[a-z]`将匹配任何小写ASCII字母，`[0-5][0-9]`将匹配00到59之间的所有两位数数字，而`[0-9A-Fa-f]`将匹配任何十六进制数字。如果`'-'`被转义(如`[a\-z]`)，或者它被放在第一个或最后一个字符(如`[-a]`或`[a-]`)，它将匹配一个字面意义上的`'-'`。 3. 字符在集合内失去其特殊意义。例如，`[(+*)]`将匹配任何文字字符`'('`、`'+'`、`'*'`或`')'`。 4. 字符类(如`\w`或`\S`)也可以在集合内被接受，尽管它们匹配的字符取决于是ASCII模式还是LOCALE模式。 5. 通过对集合进行补全，可以匹配不在一个范围内的字符。如果集合的第一个字符是`'^'`，那么所有不在集合内的字符都将被匹配。例如，`[^5]`将匹配除`'5'`之外的任何字符，而`[^^]`将匹配除`'^'`之外的任何字符。如果不是第一个字符，就没有特殊意义。 6. 要匹配一个集合中的文字`']'`，在它前面加上一个反斜杠，或者将它放在集合的开始。|
|`|`|`A|B`，其中A和B可以是任意的REs，创建一个正则表达式来匹配A或B。任意数量的REs可以通过`'|'`以这种方式分隔。这也可以在组内部使用。在扫描目标字符串时，将从左到右尝试用`'|'`分隔的REs。当一个模式完全匹配时，该分支被接受。这意味着一旦A匹配，就不会对B进行进一步测试，即使这会产生更长的整体匹配。要匹配文字`'|'`，使用`\|`，或将其包含在字符类中，如`[|]`。|
|`(...)`|匹配括号内的任何正则表达式，并指示组的开始和结束；可以在执行匹配之后检索组的内容，并且可以稍后在字符串中使用`\number`特殊序列进行匹配，如下所述。要匹配文字`'('`或`')'`，使用`\(`或`\)`，或将它们包含在字符类`[(]`，`[)]`中。|
|`(?<!...)`|如果字符串中的当前位置之前没有匹配`'...'`，这称为负向后行断言。与正向后行断言类似，所包含的模式必须只匹配某个固定长度的字符串。以负向后行断言开始的模式可能与正在搜索的字符串的开头匹配。|
|`(?aiLmsux-imsx:...)`|(a、i、L、m、s、u、x集合中的0个或多个字母，可选地后面跟着`'-'`和i、m、s、x中的一个或多个字母。)这些字母设置或删除了表达式部分对应的标志:`re.A`(只匹配ascii)、`re.I`(忽略大小写)、`re.L`(依赖于语言环境)、`re.M`(多行)、`re.S`(点匹配全部)、`re.U`(Unicode匹配)和`re.X` (verbose)。|

**特殊序列：**

特殊的序列由`\`和下面列表中的一个字符组成。如果普通字符不是ASCII数字或ASCII字
母，则生成的RE将匹配第二个字符。例如，`\$`匹配字符`'$'`。

|符号|含义|
| - | - |
|`\number`|匹配相同编号的组的内容。组从1开始编号。例如，`(.+)\1`匹配`'the the'`或`'55 55'`，但不匹配`'thethe'`(注意组后面的空格)。这个特殊的序列只能用于匹配前99个组中的一个。如果number的第一个数字是0，或者number是3个八进制长，它将不会被解释为组匹配，而是被解释为具有八进制值number的字符。在字符类的`'['`和`']'`内部，所有数字转义都被视为字符。|
|`\A`|只在字符串的开头匹配。|
|`\b`|匹配空字符串，但仅在单词的开头或结尾。一个单词被定义为一个单词字符序列。注意，在形式上，`\b`被定义为`\w`和`\W`字符之间的边界(反之亦然)，或者`\w`和字符串的开始/结束之间的边界。这意味着`r'\bfoo\b'`匹配`'foo'`， `'foo.'`， `'(foo)'`， `'bar foo baz'`，而不是`'foobar'`或`'foo3'`。默认情况下，Unicode字母数字是Unicode模式中使用的字母数字，但这可以通过使用ASCII标志来更改。如果使用语言环境标志，则单词边界由当前语言环境确定。在一个字符范围内，`\b`表示退格字符，以与Python的字符串文本兼容。|
|`\B`|匹配空字符串，但仅当它不在单词的开头或结尾时。这意味着`r'py\B'`匹配`'python'`，`'py3'`，`'py2'`，但不匹配`'py'`，`'py.'`,或`'py!'`。`\B`与`\b`正好相反，因此Unicode模式中的word字符是Unicode字母数字或下划线，尽管这可以通过使用ASCII标志来更改。如果使用语言环境标志，则单词边界由当前语言环境确定。|
|`\d`|对于Unicode (str)模式:匹配任何Unicode十进制数字(即Unicode字符类别[Nd]中的任何字符)。这包括`[0-9]`和许多其他数字字符。如果使用ASCII标志，则只匹配`[0-9]`。对于8位(字节)模式:匹配任何十进制数字;这相当于`[0-9]`。|
|`\D`|匹配任何不是十进制数字的字符。这是`\d`的反义词。如果使用ASCII标志，那么它就等于`[^0-9]`。|
|`\s`|对于Unicode (str)模式:匹配Unicode空格字符(包括`[\t\n\r\f\v]`，以及许多其他字符，例如许多语言中排版规则所要求的不间断空格)。如果使用ASCII标志，只有`[\t\n\r\f\v]`匹配。对于8位(字节)模式:匹配ASCII字符集中的空格字符;它等价于`[\t\n\r\f\v]`|
|`\S`|匹配任何不是空白字符的字符。这是`\s`的反义词。如果使用ASCII标志，它就等于`[^ \t\n\r\f\v]`。|
|`\w`|For Unicode (str)模式:匹配Unicode单词字符;这包括可以在任何语言中成为单词一部分的大多数字符，以及数字和下划线。如果使用ASCII标志，则只有`[a-zA-Z0-9_]`匹配。对于8位(字节)模式:匹配ASCII字符集中认为是字母数字的字符;这相当于`[a-zA-Z0-9_]`。如果使用区域设置标志，则匹配当前区域设置中视为字母数字的字符和下划线。|
|`\W`|匹配任何不是单词字符的字符。这是\w的反义词。如果使用ASCII标志，那么它就等于`[^a-zA-Z0-9_]`。如果使用区域设置标志，则匹配既不是当前区域设置中的字母数字也不是下划线的字符。|
|`\Z`|只在字符串的末尾匹配。|

## 模块内容

- `re.compile(pattern, flags=0)`
  
  将正则表达式模式编译为正则表达式对象，该对象可用于使用下面描述的match()、
  search()和其他方法进行匹配。

  可以通过指定标志值来修改表达式的行为。使用或(`'|'`操作符)组合而成。

  但是，当表达式将在一个程序中多次使用时，使用`re.compile()`并保存生成的正则表达式
  对象以供重用更有效。
  
- `re.A`
  
- `re.ASCII`
  
  使`\w`，`\W`，`\b`，`\B`，`\d`，`\D`，`\s`和`\S`执行仅ascii匹配而不是完全Unicode匹配。这只对
  Unicode模式有意义，对字节模式则忽略不计。对应于inline标志`(?a)`。
  
- `re.I`
  
- `re.IGNORECASE`
  
  执行不区分大小写的匹配;像`[A-Z]`这样的表达式也将匹配小写字母。完全Unicode匹配也
  可以使用，除非使用`re.ASCII`标志禁用非ascii匹配。除非还使用了`re.LOCALE`标志，否则
  当前区域设置不会改变此标志的效果。对应于inline标志`(?i)`。
  
- `re.M`
  
- `re.MULTILINE`
  
  当指定时，模式字符`'^'`匹配字符串的开头和每行的开头(紧接每个换行之后);模式字符
  `'$'`在字符串的末尾和每行的末尾(紧接每个换行的前面)匹配。默认情况下，`'^'`只在字
  符串的开头匹配，而`'$'`只在字符串的结尾和字符串末尾的换行符(如果有的话)之前匹
  配。对应于inline标志`(?m)`。
  
- `re.S`
  
- `re.DOTALL`
  
  使`'.'`特殊字符完全匹配任何字符，包括换行符;如果没有这个标志，`'.'`将匹配除换行符
  之外的任何内容。对应于inline标志`(?s)`。
  
- `re.X`
  
- `re.VERBOSE`
  
  这个标志允许从视觉上分离模式的逻辑部分并添加注释，从而使编写的正则表达式看起来
  更好，可读性更强。模式中的空格会被忽略，除非是在字符类中，或者前面有未转义的反
  斜杠，或者是在`*?`,`(?:`或者`(?P<…>`里。如果一行包含的#不在字符类中，并且前面没有未
  转义的反斜杠，那么从最左边的#到行尾的所有字符都将被忽略。
  
- `re.search(pattern, string, flags=0)`
  
  扫描字符串，查找正则表达式模式产生匹配的第一个位置，并返回对应的匹配对象。如果
  字符串中没有位置与模式匹配，则返回None；注意，这不同于在字符串的某个点上找到长
  度为零的匹配。
  
- `re.match(pattern, string, flags=0)`
  
  如果字符串开头的零个或多个字符与正则表达式模式匹配，则返回一个对应的match对
  象。如果字符串与模式不匹配，则返回None；注意，这与零长度匹配不同。注意，即使在
  多行模式下，`re.match()`也只匹配字符串的开头，而不是每行的开头。
  
- `re.split(pattern, string, maxsplit=0, flags=0)`
  
  按出现的模式拆分字符串。如果在模式中使用捕获括号，那么模式中所有组的文本也将作
  为结果列表的一部分返回。如果maxsplit非零，最多会发生maxsplit分割，并将字符串的
  其余部分作为列表的最后一个元素返回。
  如果分隔符中有捕获组，并且在字符串的开始处匹配，则结果将以空字符串开始。字符串
  的结尾也是一样的。
  
- `re.findall(pattern, string, flags=0)`
  
  以字符串列表的形式返回所有模式的非重叠匹配。从左到右扫描字符串，并按照找到的顺
  序返回匹配项。如果模式中有一个或多个组，则返回组列表；如果模式有多个组，这将是
  一个元组列表。结果中包含空匹配项。
  
- `re.finditer(pattern, string, flags=0)`
  
  返回一个迭代器，在字符串中的RE模式的所有非重叠匹配上生成匹配对象。从左到右扫描
  字符串，并按照找到的顺序返回匹配项。结果中包含空匹配项。

- `re.sub(pattern, repl, string, count=0, flags=0)`
  
  返回通过替换repl替换字符串中最左边不重叠的模式所获得的字符串。如果没有找到模
  式，字符串将不加更改地返回。repl可以是字符串或函数;如果是字符串，则处理其中的
  任何反斜杠转义。也就是说，`\n`被转换为单个换行字符，`\r`被转换为回车符，依此类推。
  未知ASCII字母的转义将保留以备将来使用，并作为错误处理。其他未知的转义如`\&`被单
  独留下。反向引用(例如`\6`)被替换为模式中由组6匹配的子字符串。
  
- `re.subn(pattern, repl, string, count=0, flags=0)`
  
  执行与sub()相同的操作，但是返回一个元组(new_string, number_of_subs_made)。

## 正则表达式对象

编译后的正则表达式对象支持以下方法和属性:

- `Pattern.search(string[, pos[, endpos]])`
  
  扫描字符串，查找正则表达式产生匹配的第一个位置，并返回相应的匹配对象。如果字符
  串中没有位置与模式匹配，则返回None；这不同于在字符串的某个点上找到长度为零的匹
  配。
  
  第二个可选参数pos在搜索开始的字符串中给出一个索引；它默认为0。这并不完全等同于
  对字符串进行切片;`'^'`模式字符在字符串的真正开头和换行后的位置匹配，但不一定在搜
  索开始的索引处匹配。
  
  可选参数endpos限制搜索字符串的距离;就好像字符串是结束字符一样长，所以只搜索从
  endpos到endpos-1的字符来匹配。如果endpos小于pos，则不匹配;否则，如果rx是编译后
  的正则表达式对象，则为`rx.search(string,0,50)`等价于`rx.search(string[:50],0)`。
  
- `Pattern.match(string[, pos[, endpos]])`
  
  如果字符串开头的零个或多个字符与此正则表达式匹配，则返回一个对应的match对象。
  如果字符串与模式不匹配，则返回None；这与零长度匹配不同。

  可选的pos和endpos参数与search()方法具有相同的含义。

- `Pattern.fullmatch(string[, pos[, endpos]])`
  
  如果整个字符串匹配此正则表达式，则返回相应的匹配对象。如果字符串与模式不匹配，
  则返回None；与零长度匹配不同。
  
  可选的pos和endpos参数与search()方法具有相同的含义。
  
- `Pattern.split(string, maxsplit=0)`
  
  与split()函数相同，使用编译模式。

- `Pattern.findall(string[, pos[, endpos]])`
  
  与findall()函数类似，使用编译模式，但也接受限制搜索区域的可选pos和endpos参数。

- `Pattern.finditer(string[, pos[, endpos]])`
  
  与finditer()函数类似，使用编译模式，但也接受可选的pos和endpos参数，这些参数限
  制搜索区域。
  
- `Pattern.sub(repl, string, count=0)`
  
  与sub()函数相同，使用编译模式。

## 匹配对象

匹配对象的布尔值始终为True。

匹配对象支持以下方法和属性:

- `Match.expand(template)`
  
  返回通过在模板字符串template上执行反斜杠替换获得的字符串，就像sub()方法所做的
  那样。`\n`等转义符被转换为适当的字符，数值反引用`(\1，\2)`和命名反引用`(\g<1>，
  \g<name>)`被替换为对应组的内容。
  
- `Match.group([group1, ...])`
  
  返回匹配项的一个或多个子组。如果有一个参数，结果是一个字符串;如果有多个参数，
  结果是一个元组，每个参数有一个项。如果没有参数，group1默认为零(返回整个匹配)。
  如果groupN参数为0，则对应的返回值为整个匹配字符串;如果它在包含范围[1..99]，它
  是与对应的带括号的组匹配的字符串。如果组号为负数或大于模式中定义的组数，则会引
  发IndexError异常。如果一个组包含在不匹配的模式部分中，则对应的结果为None。如果
  一个组包含在多次匹配的模式的一部分中，则返回最后一个匹配项。
  
- `Match.start([group]), Match.end([group])`
  
  返回组匹配的子字符串的开始和结束的索引;group默认值为零(表示整个匹配的子字符
  串)。如果组存在但没有匹配，则返回-1。


# 以 teachercrawl.py 为例

下面对 teachercrawl.py 文件中的正则表达式的函数应用进行回顾：

**函数一：`re.compile()`**

1. 使用情景：如果一个正则表达式要重复使用几千次，出于效率的考虑，应该先把这个正
   则先**预编译**好，接下来重复使用时就不再需要编译这个步骤，直接匹配，从而提高
   效率；

2. 使用形式：`re.compile(pattern[, flag])`

   1）`pattern` 是一个字符串形式的正则表达式；

   2）`flag` 是一个可选参数，表示匹配模式，比如忽略大小写 `re.I`，多行模式 `re.S` 等。

3. 从 `compile()` 函数的定义中，可以看出返回的是一个匹配对象，它单独使用就没有任何
   意义，需要和 `findall()`, `search()`, `match()` 搭配使用:

   1）`compile()`与`findall()`一起使用，返回一个列表。

   2）`compile()`与`match()`一起使用，可返回一个`class`、`str`、`tuple`。

**例1：**

```{python}
import re                # 正则表达式

text = '师资队伍\n全院教师队伍\n硕士研究生导师\n博士研究生导师\n全院教师队伍\n当前位置：首页  师资队伍  全院教师队伍\n马克思主义基本原理教研部党支部书记、主任:荣枢'
phrases = ['正文','正 *文','首页','首 *页','网站首页','位置','位 *置','当前所在位置']

for i in phrases: 
    if i in text:    # 判断 i 是否在 text 中
        patt = re.compile(''.join((i,'.*')), re.S)    # 返回patten对象; re.S
        text_output = re.findall(patt, text)[-1]      # 返回 i 后面所有文本
print(text_output)

print(re.findall('位置(.*)', text))         # 结果:['：首页  师资队伍  全院教师队伍']
print(re.findall('位置(.*)', text, re.S))   # 结果：['：首页  师资队伍  全院教师队伍\n马克思主义基本原理教研部党支部书记、主任:荣枢']
```

**（补充说明）`re.S` : 匹配包括换行\n在内的所有字符**

1. 如果不使用 `re.S` 参数，则只在每一行内进行匹配，如果一行没有，就换下一行重新开始，**不会跨行**。

2. 而使用 `re.S` 参数以后，正则表达式会将这个字符串作为一个整体，将“\n”当做一个普通的字
符加入到这个字符串中，**在整体中进行匹配**。


**函数二：`re.sub()`**

1. 使用形式：`re.sub(pattern, repl, string, count=0, flags=0)`

   1）三个必选参数：`pattern` (表示正则中的模式字符串), `repl` (被替换的字符串的意
   思), `string`(表示要被替换的那个字符串)；

   2）两个可选参数：`count` (对于匹配到的内容，只处理其中一部分；默认0，作用是无限
   替换下去), `flags`（表示匹配模式，比如忽略大小写 `re.I`，多行模式 `re.S` 等）。

2. 函数作用：实现**正则替换**。

**例2：**

```{python}
text_output=re.sub(r'([0-9a-z]{200,300})|(\xa0)|(\ufeff)|(\u3000)','',text_output)#把text_output中的 \xa0、\ufeff、\u3000 等字符替换成 " "，以及去除加密信息

text_output=re.sub(r' +'," ", text_output)        # 把多个空格替换成一个空格
text_output=re.sub(r'( ?\n)+',"\n", text_output)  # 把多个换行符替换成一个换行符
text_output=re.sub(r'( ?\r)+',"\r", text_output)  # 把多个回车符替换成一个回车符
cleanedtext=re.sub(r'( ?\t)+',"\t", text_output)  # 把多个横向制表符替换成一个横向制表符
```
